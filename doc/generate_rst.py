# This script generates a set of .md (MarkDown) files
# from xml files generated by doxygen.

# The script does two sweeps. 
# First all xml are parsed and stored in dictionaries
# with their id as key.
# The second sweep generates one page (a markdown file) pr class
# and collects the information for main page which is generated
# at the end.

import sys, os
from xml.etree import ElementTree

input_dir = os.path.abspath(sys.argv[1])
output_dir = os.path.abspath(sys.argv[2])

if not os.path.exists(os.path.join(output_dir, "API")) :
    os.mkdir(os.path.join(output_dir, "API"))


print("Reading files from %s" % input_dir)

# save all the classes as dictionary with doxygens id as key.
cls = {}

# First sweep
for filename in os.listdir(input_dir) :
    if not os.path.isfile(os.path.join(input_dir, filename)) :
        continue

    if not filename.endswith(".xml") :
        continue

    # Only classes are documented now
    if not filename.startswith("class") :
        continue

    # print("Processing %s" % filename)

    root = ElementTree.parse(os.path.join(input_dir, filename)).getroot()
    assert root.tag == "doxygen"
    assert len(root) == 1

    class_def = root.find("compounddef")
    assert not cls.has_key(class_def.attrib["id"])

    class_name = class_def.find("compoundname").text
    outfilename_base = class_name if not class_name.startswith("mshr::") else class_name[6:]
    briefdescription = class_def.find("briefdescription")
    # Description should at most one paragraph
    assert (len(briefdescription) <= 1) 
    briefdescription = briefdescription.find("para").text if briefdescription.find("para") is not None else ""
    
    data = {'filename'    : outfilename_base,
            'description' : briefdescription.strip() }

    # print data["filename"]

    cls[class_def.attrib["id"]] = (class_def, data)

print len(cls)

longest_class_name  = max([ len(c[0].find("compoundname").text) for k, c in cls.iteritems()])
longest_description = max([ len(c[1]["description"]) for k, c in cls.iteritems()])

primitives2d = []
primitives3d = []
operators    = []
others       = []


# Second sweep
for k,c in cls.iteritems() :
    theclass = c[0]
    classname = theclass.find("compoundname").text
    classid = theclass.attrib["id"]
    print "Processing "+classname

    classpage = []
    category = others

    # inheritance
    # also decides which category the class belong to
    inheritance = theclass.find("inheritancegraph")
    if inheritance is not None :
        inheritancenodes = {}
        nodes = inheritance.findall("node")

        # collect all in a dictionary with the refid (which is not the same
        # as the class id as key
        myid = False
        for x in nodes : 
            inheritancenodes[x.attrib["id"]] = x
            link = x.find("link")
            
            # save the refif to self
            if link is not None and link.attrib["refid"] == classid :
                myid = x.attrib["id"]

        # traverse the tree from self through all super classes
        current = inheritancenodes[myid]
        current = inheritancenodes[current.find("childnode").attrib["refid"]]
        inheritance_list = []
        while current is not None :
            label = current.find("label").text
            print "Label: %s" % label
            if label == "mshr::CSGPrimitive2D"   : category = primitives2d
            elif label == "mshr::CSGPrimitive3D" : category = primitives3d
            elif label == "mshr::CSGOperator"    : category = operators

            ref = current.find("link")

            if ref is not None and cls.has_key(ref.attrib["refid"]) :
                inheritance_list.append("[%s](%s)" % (current.find("label").text.strip(),
                                                      cls[ref.attrib["refid"]][1]["filename"]))
            else :
                inheritance_list.append(x.find("label").text.strip())

            child = current.find("childnode")
            if child is not None :
                current = inheritancenodes[child.attrib["refid"]]
            else :
                current = None


        category.append("[%s](API/%s)|%s|\n" % (classname.ljust(longest_class_name), 
                                                c[1]["filename"],
                                                c[1]["description"].ljust(longest_description)))


        inheritance_list.reverse()
        classpage.append("_" + " < ".join(inheritance_list) + "_")
        classpage.append("\n\n")


    classpage.append("## %s\n\n" % (classname))
    classpage.append("_%s_\n\n" % c[1]["description"])

    classpage.append("#### Public functions\n")
    for member in c[0].findall("sectiondef") :

        # Only public functions are considered part of the public API for now
        if member.attrib["kind"] != "public-func" :
            continue

        for definition in member.findall("memberdef") :
            membername = definition.find("name").text
            argsstr    = definition.find("argsstring").text
            description = definition.find("briefdescription").find("para")
            # print "  "+membername
            description = description.text.strip() if description is not None else ""

            # name
            classpage.append(" **%s**%s\n\n" % (membername, argsstr))

            # description
            if description :
                classpage.append("  _%s_\n\n" % description)

    with open(os.path.join(output_dir, "API", c[1]["filename"]+".md"), "w") as f:
        f.write("".join(classpage))
        f.close()



# Create the main page for 
mainpage = ["""

## API reference

"""]

mainpage.append("%s|%s|\n" % ("2D primitives".ljust(longest_class_name),
                              "Description".ljust(longest_description)))

mainpage.append("%s|%s|\n" % ( ":".ljust(longest_class_name, "-"),
                               ":".ljust(longest_description, "-")))


################# Append 2D primitives
#mainpage.append("%s|%s|\n" % ("**2D primitives**".ljust(longest_class_name),
#                              "".ljust(longest_description)))

# mainpage.append("%s|%s|\n" % ( ":".ljust(longest_class_name, "-"),
#                                ":".ljust(longest_description, "-")))

mainpage.append("".join(primitives2d))
#mainpage.append("\n\n")

################ Append 3D primitives
mainpage.append("%s|%s|\n" % ("**3D primitives**".ljust(longest_class_name),
                              "**Description**".ljust(longest_description)))

# mainpage.append("%s|%s|\n" % ( ":".ljust(longest_class_name, "-"),
#                                ":".ljust(longest_description, "-")))

mainpage.append("".join(primitives3d))
#mainpage.append("\n\n")

############### Append operators
mainpage.append("%s|%s|\n" % ("**Operators**".ljust(longest_class_name),
                              "**Description**".ljust(longest_description)))

# mainpage.append("%s|%s|\n" % ( ":".ljust(longest_class_name, "-"),
#                               ":".ljust(longest_description, "-")))

mainpage.append("".join(operators))
# mainpage.append("\n\n")

############### Append other classes
mainpage.append("%s|%s|\n" % ("**Other classes**".ljust(longest_class_name),
                              "**Description**".ljust(longest_description)))

# mainpage.append("%s|%s|\n" % ( ":".ljust(longest_class_name, "-"),
#                               ":".ljust(longest_description, "-")))

mainpage.append("".join(others))
mainpage.append("\n\n")



with open(os.path.join(output_dir, "API.md"), "w") as f:
    f.write("".join(mainpage))
    f.close()

