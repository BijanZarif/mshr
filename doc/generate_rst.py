# This script generates a set of .rst (reStructured Text) files
# from xml files generated by doxygen

import sys, os
from xml.etree import ElementTree

input_dir = os.path.abspath(sys.argv[1])
output_dir = os.path.abspath(sys.argv[2])

if not os.path.exists(os.path.join(output_dir, "API")) :
    os.mkdir(os.path.join(output_dir, "API"))


print("Reading files from %s" % input_dir)

# save all the classes as dictionary with doxygens id as key.
cls = {}
primitives2D = {}
primitives3D = {}


for filename in os.listdir(input_dir) :
    if not os.path.isfile(os.path.join(input_dir, filename)) :
        continue

    if not filename.endswith(".xml") :
        continue

    # Only classes are documented now
    if not filename.startswith("class") :
        continue

    # print("Processing %s" % filename)

    root = ElementTree.parse(os.path.join(input_dir, filename)).getroot()
    assert root.tag == "doxygen"
    assert len(root) == 1

    class_def = root.find("compounddef")
    assert not cls.has_key(class_def.attrib["id"])

    class_name = class_def.find("compoundname").text
    outfilename_base = class_name if not class_name.startswith("mshr::") else class_name[6:]
    briefdescription = class_def.find("briefdescription")
    # Description should at most one paragraph
    assert (len(briefdescription) <= 1) 
    briefdescription = briefdescription.find("para").text if briefdescription.find("para") is not None else ""
    
    data = {'filename'    : outfilename_base,
            'description' : briefdescription.strip() }

    # print data["filename"]

    cls[class_def.attrib["id"]] = (class_def, data)

print len(cls)

longest_class_name  = max([ len(c[0].find("compoundname").text) for k, c in cls.iteritems()])
longest_description = max([ len(c[1]["description"]) for k, c in cls.iteritems()])

# Create the main page for 
mainpage = ["""

## API reference

"""]

mainpage.append("%s|%s|\n" % ("Class".ljust(longest_class_name),
                            "Description".ljust(longest_description)))

mainpage.append("%s|%s|\n" % ( ":".ljust(longest_class_name, "-"),
                               ":".ljust(longest_description, "-")))

for k,c in cls.iteritems() :
    theclass = c[0]
    classname = theclass.find("compoundname").text
    classid = theclass.attrib["id"]
    print "Processing "+classname
    mainpage.append("[%s](API/%s)|%s|\n" % (classname.ljust(longest_class_name), 
                                            c[1]["filename"],
                                            c[1]["description"].ljust(longest_description)))

    classpage = []

    # inheritance
    inheritance = theclass.find("inheritancegraph")
    if inheritance is not None :
        inheritancenodes = {}
        nodes = inheritance.findall("node")
        # sup_list = sorted(superclasses, key=lambda x : -int(x.attrib["id"]))
        myid = False
        for x in nodes : 
            inheritancenodes[x.attrib["id"]] = x
            link = x.find("link")
            if link is not None and link.attrib["refid"] == classid :
                myid = x.attrib["id"]

        current = inheritancenodes[myid]
        current = inheritancenodes[current.find("childnode").attrib["refid"]]
        inheritance_list = []
        while current is not None :
            ref = current.find("link")
            print ref
            if ref is not None and cls.has_key(ref.attrib["refid"]) :
                print "Link"
                inheritance_list.append("[%s](%s)" % (current.find("label").text.strip(),
                                                      cls[ref.attrib["refid"]][1]["filename"]))
            else :
                inheritance_list.append(x.find("label").text.strip())

            child = current.find("childnode")
            if child is not None :
                current = inheritancenodes[child.attrib["refid"]]
            else :
                current = None


        inheritance_list.reverse()
        classpage.append("_" + " < ".join(inheritance_list) + "_")
        classpage.append("\n\n")


    classpage.append("## %s\n\n" % (classname))
    classpage.append("_%s_\n\n" % c[1]["description"])

    classpage.append("#### Public functions\n")
    for member in c[0].findall("sectiondef") :

        # Only public functions are considered part of the public API for now
        if member.attrib["kind"] != "public-func" :
            continue

        for definition in member.findall("memberdef") :
            membername = definition.find("name").text
            argsstr    = definition.find("argsstring").text
            description = definition.find("briefdescription").find("para")
            # print "  "+membername
            description = description.text.strip() if description is not None else ""

            # name
            classpage.append(" **%s**%s\n\n" % (membername, argsstr))

            # description
            if description :
                classpage.append("  _%s_\n\n" % description)

    with open(os.path.join(output_dir, "API", c[1]["filename"]+".md"), "w") as f:
        f.write("".join(classpage))
        f.close()

with open(os.path.join(output_dir, "API.md"), "w") as f:
    f.write("".join(mainpage))
    f.close()

